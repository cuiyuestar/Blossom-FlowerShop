---当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，
---如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，
---说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，
---整个过程需要保证是原子性的，我们可以使用lua来操作
---
---当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，
---如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，
---前端可以通过返回的订单id来判断是否下单成功。
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 20166.
--- DateTime: 2024/11/10 12:57
---
--1.参数列表
--1.1优惠卷id
local voucherId=ARGV[1]
--1.2 用户id
local userId=ARGV[2]
--1.3 订单id
local orderId=ARGV[3]
--

--2数据key
-- 2.1 库存key
local stockKey='seckill:stock:' .. voucherId
local orderKey='seckill:order:' .. voucherId

--3.脚本业务
--3.1判断库存是否充足 get stockKey
if(tonumber(redis.call('get',stockKey))<=0) then
    --3.2库存不足，返回1
    return 1
end
--3.2 判断用户是否下单 SISMEMBER orderKey userId
if(redis.call('sismember',orderKey,userId)==1) then
    --3.3存在，说明重复下单，返回2
    return 2
end
--3.4 扣库存 incrby stockKey -1
redis.call('incrby',stockKey,-1)
--3.5下单（保存用户）sadd orderKey userId
redis.call('sadd',orderKey,userId)
--3.6 发送消息到队列，XADD stream.orders * k1 v1 k2 v2...
redis.call('xadd','stream.orders','*','userId',userId,'voucherId',voucherId,'id',orderId)
return 0